use crate::{EEGData, EEGInfo};
use egui_plot::{Line, Plot, PlotPoints};

/// We derive Deserialize/Serialize so we can persist app state on shutdown.
//#[derive(serde::Deserialize, serde::Serialize)]
//#[serde(default)] // if we add new fields, give them default values when deserializing old state
pub struct TemplateApp {
    // Example stuff:

    //#[serde(skip)] // This how you opt-out of serialization of a field
    //value: f32,

    //#[serde(skip)]
    info: EEGInfo,
    //#[serde(skip)]
    data: EEGData,
    //#[serde(skip)]
    cch: usize,
    ampl: usize,
    mms: usize

}

impl TemplateApp {
    /// Called once before the first frame.
    pub fn new(cc: &eframe::CreationContext<'_>, info: EEGInfo, data: EEGData) -> Self {
        // This is also where you can customize the look and feel of egui using
        // `cc.egui_ctx.set_visuals` and `cc.egui_ctx.set_fonts`.
        Self{
            info: info,
            data: data,
            cch: 0,
            ampl: 100,
            mms: 30
        }
        // Load previous app state (if any).
        // Note that you must enable the `persistence` feature for this to work.
        //if let Some(storage) = cc.storage {
          //  eframe::get_value(storage, eframe::APP_KEY).unwrap_or_default()
       // } else {
         //   Default::default()
       // }
    }
}

impl eframe::App for TemplateApp {
    /// Called by the framework to save state before shutdown.
    //fn save(&mut self, storage: &mut dyn eframe::Storage) {
      //  eframe::set_value(storage, eframe::APP_KEY, self);
    //}

    /// Called each time the UI needs repainting, which may be many times per second.
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // Put your widgets into a `SidePanel`, `TopBottomPanel`, `CentralPanel`, `Window` or `Area`.
        // For inspiration and more examples, go to https://emilk.github.io/egui

        egui::TopBottomPanel::top("top_panel").show(ctx, |ui| {
            // The top panel is often a good place for a menu bar:

            egui::MenuBar::new().ui(ui, |ui| {
                // NOTE: no File->Quit on web pages!
                let is_web = cfg!(target_arch = "wasm32");
                if !is_web {
                    ui.menu_button("File", |ui| {
                        if ui.button("Quit").clicked() {
                            ctx.send_viewport_cmd(egui::ViewportCommand::Close);
                        }
                    });
                    ui.add_space(16.0);
                }
                egui::widgets::global_theme_preference_buttons(ui);
            });
        });

        egui::CentralPanel::default().show(ctx, |ui| {
            // The central panel the region left after adding TopPanel's and SidePanel's
            ui.heading("reegui");

            ui.horizontal(|ui| {
                ui.label("EEG channels: ");
                            });
            let alternatives = &self.info.ch_namesx;
            egui::ComboBox::from_label("Select one!").show_index(
                ui,
                &mut self.cch,
                alternatives.len(),
                |i| &alternatives[i]
            );
           

             ui.horizontal(|ui| {
                ui.label("mm/s: ");
                ui.add(egui::Slider::new(&mut self.mms, 1..=100));
            });

             ui.horizontal(|ui| {
               ui.label("Gain: ");
                ui.add(egui::Slider::new(&mut self.ampl, 1..=1000));
            });
            //
            let one_channel = self.data.data.row(self.cch);
            let points: PlotPoints = one_channel.iter().enumerate().step_by(30).map(|(i, &sample)| {

                let x = i as f64 / self.info.sfreq as f64;
                let y = sample as f64 / self.ampl as f64;
                [x, y]
            }).collect();
            
            let line = Line::new("EEG", points);
            
            Plot::new("my_plot")
                .show(ui, |plot_ui| {
                    plot_ui.line(line);

                    // Get the center of the user's current view
                    let center = plot_ui.plot_bounds().center();

                    // Create a new bounds object using the .x and .y fields of the PlotPoint
                    let new_bounds = egui_plot::PlotBounds::from_min_max(
                        [center.x - self.mms as f64 / 2.0, center.y - self.ampl as f64],
                        [center.x + self.mms as f64 / 2.0, center.y + self.ampl as f64],
                    );

                    // Set the plot to these new, dynamically controlled bounds
                    plot_ui.set_plot_bounds(new_bounds);
                });


            egui::widgets::global_theme_preference_buttons(ui);

    
            if ui.button("Increment").clicked() {
                //self.value += 1.0;
            }

            ui.separator();

            ui.add(egui::github_link_file!(
                "https://github.com/emilk/eframe_template/blob/main/",
                "Source code."
            ));

            ui.with_layout(egui::Layout::bottom_up(egui::Align::LEFT), |ui| {
                powered_by_egui_and_eframe(ui);
                egui::warn_if_debug_build(ui);
            });
        });
    }
}

fn powered_by_egui_and_eframe(ui: &mut egui::Ui) {
    ui.horizontal(|ui| {
        ui.spacing_mut().item_spacing.x = 0.0;
        ui.label("Powered by ");
        ui.hyperlink_to("egui", "https://github.com/emilk/egui");
        ui.label(" and ");
        ui.hyperlink_to(
            "eframe",
            "https://github.com/emilk/egui/tree/master/crates/eframe",
        );
        ui.label(".");
    });
}
use std::fs;
use std::io;
use std::fs::File;
use std::io::prelude::*;
use std::io::BufReader;

use egui::AtomExt;
use egui::IntoAtoms;
//use byteorder::{BigEndian, LittleEndian, ReadBytesExt, WriteBytesExt};
use ndarray::prelude::*;

use crate::EEGInfo;

//fn type_of<T>(_: T) -> &'static str {
//    type_name::<T>()
//}

pub fn get_header(fpath: &Option<String>) -> Result<Option<String>, Box<dyn std::error::Error>> {
    match  fpath {
        Some(path) => {
        let mut file = File::open(path)?;
        let mut header = String::new();
        file.read_to_string(&mut header)?;
        Ok(Some(header))
        }
     
    None => Ok(None),
    }

}

pub fn parse_header(header: &Option<String>) -> Result<EEGInfo, Box<dyn std::error::Error>> {
    
    let header_content = match header {
        Some(content) => content,
        // Return a clear error if the header is needed but not provided.
        None => return Err("Header content is missing and required for this operation.".into()),
    };
    
    let header_vec: Vec<String> = header_content.split("\n").map(|x| x.to_string()).collect();

    let mut eeg_info = EEGInfo {
        num_ch: 0,
        ch_namesx: Vec::new(),
        ch_names: Vec::new(),
        sfreq: 0,
        data_orientation: String::new(),
        binary_format: String::new(),
        sampling_interval_in: String::new(),
        sampling_interval: 0,
    };
    //Prints the whole header
    //header_vec.iter().for_each(|x| println!("Lines {:?}", x));

    //println!("Header {:?}", header_vec);
    let mut header_str = String::new();
    header_vec.iter().for_each(|x| {
        if x.contains("Sampling Rate [Hz]") {
            header_str.push_str(x);
            header_str.push_str("\n");
            //println!("SFREQ: {}", &x[20..].replace("\r", ""));
            eeg_info.sfreq = x[20..].replace("\r", "").parse::<i32>().unwrap();
            println!("Sampling rate {:?}", eeg_info.sfreq);
        }

        if x.contains("Number of channels:") {
            header_str.push_str(x);
            header_str.push_str("\n");
            //println!("N: {}", &x[20..]);
            let n_ch = x[20..].replace("\r", "").parse::<i32>().unwrap(); // Should make this more
            //solid
            //println!("NCH: {}", n_ch);
            eeg_info.num_ch = n_ch;

            println!("Number of channels {:?}", n_ch);

            for i in 0..n_ch {
                eeg_info.ch_namesx.push(format!("Ch{}", i + 1));
            }
            //println!("CHANNELSXX: {:?}", eeg_info.ch_namesx);
        }

        if x.contains("DataOrientation") {
            header_str.push_str(x);
            //header_str.push_str("\n");
            //println!("SFREQ: {}", &x[20..].replace("\r", ""));
            eeg_info.data_orientation = x.replace("\r", "");
            println!("Data orientation {:?}", eeg_info.data_orientation);
        }

        if x.contains("BinaryFormat") {
            header_str.push_str(x);
            eeg_info.binary_format = x.replace("BinaryFormat=", "").replace("\r", "");
            println!("Binary format {:?}", eeg_info.binary_format);
        }

        if x.contains("Sampling interval in") {
            header_str.push_str(x);
            eeg_info.sampling_interval_in = x.replace("Sampling interval in", "").replace("\r", "");
        }

        if x.contains("SamplingInterval") {
            header_str.push_str(x);
            eeg_info.sampling_interval = x
                .replace("SamplingInterval=", "")
                .replace("\r", "")
                .parse::<i32>()
                .unwrap();
        }
    });

   // header_vec.iter().for_each(|x| {
     //   for ch in &eeg_info.ch_namesx {
       //     if x.contains(ch) {
                //println!("CHANNEL: {:?}", x);
         //       eeg_info
           //         .ch_names
             //       .push(x.to_string().replace(",,1,ÂµV\r", "").replace("Ch", ""));
            //}
     //   }
    //});

    //println!("Header: {:?}", header_str);
    //println!("{:?}", eeg_info);
    Ok(eeg_info)
}


pub fn parse_bytes(path: &str, eeg_info: &EEGInfo) -> Result<Vec<i16>, Box<dyn std::error::Error>> {
    match eeg_info.binary_format.as_str() {
        "INT_16" => {
            let f = File::open(path).expect("could not open file");
            let mut reader: BufReader<File> = BufReader::new(f);
            let mut buffer = Vec::new();
            // Read file into vector.
            reader
                .read_to_end(&mut buffer)
                .expect("error while reading file");

            let bytes = buffer.to_vec();
            let mut samples: Vec<i16> = Vec::new();
            for pair in bytes.chunks_exact(2) {
                let p = pair.try_into().unwrap();
                samples.push(i16::from_le_bytes(p));
            }

            //print!("Samples {:?}", samples.len());
            Ok(samples)
        }
        _ => Err("Format not supported".into()),
    }
}

pub fn convert_to_seconds(
    samples: Vec<i16>,
    eeg_info: &EEGInfo,
) -> Result<Vec<Vec<i16>>, Box<dyn std::error::Error>> {
    let mut step: i32 = 0; // initialise a samples step counter
    let mut seconds: Vec<Vec<i16>> = Vec::new(); // create vector of vectors for seconds
    seconds.push(Vec::new()); // Initialise the first vector

    let mut n = 0; // initialise second counter

    for s in samples.iter() {
        seconds[n].push(*s);
        step += 1;
        if step % (eeg_info.sfreq * eeg_info.num_ch) == 0 {
            n += 1;
            seconds.push(Vec::new());
        }
    }
    Ok(seconds)
}


pub fn demultiplex(
    seconds: Vec<Vec<i16>>,
    eeg_info: &EEGInfo,
) -> Result<Vec<Vec<i16>>, Box<dyn std::error::Error>> {
    let mut channels: Vec<Vec<i16>> = vec![Vec::new(); eeg_info.num_ch as usize];
    if eeg_info.num_ch as usize == 0 {
        return Err("Number of channels cannot be zero".into());
    }
    for second in seconds {
        let mut counter = 0;
        for &val in &second {
            let channel_idx = counter % eeg_info.num_ch;
            channels[channel_idx as usize].push(val);
            counter += 1;
        }
    }
    Ok(channels)
}

pub fn vec_to_array<T, const N: usize>(v: Vec<T>) -> [T; N] {
    v.try_into()
        .unwrap_or_else(|v: Vec<T>| panic!("Expected a Vec of length {} but it was {}", N, v.len()))
}

pub fn vec_to_ndarray<T: Clone>(v: Vec<Vec<T>>) -> Array2<T> {
    if v.is_empty() {
        return Array2::from_shape_vec((0, 0), Vec::new()).unwrap();
    }
    let nrows = v.len();
    let ncols = v[0].len();
    let mut data = Vec::with_capacity(nrows * ncols);
    for row in &v {
        assert_eq!(row.len(), ncols);
        data.extend_from_slice(&row);
    }
    Array2::from_shape_vec((nrows, ncols), data).unwrap()
}


// EDF 


pub fn parse_edf(path: &str ) -> Result<Vec<i16>, Box<dyn std::error::Error>> {

            let mut file = File::open(path).expect("could not open file");

            let metadata = fs::metadata(path)?;
            println!("METADATA {:?}", metadata);
        
            let mut reader = BufReader::new(file);
            // The first 256 bytes of an EDF file contain the main header in ASCII.
            let mut header_bytes = vec![0u8; 256]; 
            // Read exactly 256 bytes into the buffer.
            reader.read_exact(&mut header_bytes)?;
            // Convert the ASCII bytes to a String.
            // Using from_utf8_lossy is safe in case of any non-ASCII characters.
            let header_str = String::from_utf8_lossy(&header_bytes).to_string();
            
            println!("\n HEADER {:?}", header_str);
            
            let f = File::open(path).expect("could not open file");
            let mut reader: BufReader<File> = BufReader::new(f);
            let mut buffer = Vec::new();
            // Read file into vector.
            reader
                .read_to_end(&mut buffer)
                .expect("error while reading file");
                
            println!("DATA {:?}", buffer.len());

            let bytes = buffer.to_vec();
            let mut samples: Vec<i16> = Vec::new();
            for pair in bytes.chunks_exact(2) {
                let p = pair.try_into().unwrap();
                samples.push(i16::from_le_bytes(p));
            }

            //print!("Samples {:?}", samples.len());
            Ok(samples)
        }


#![warn(clippy::all, rust_2018_idioms)]
use ndarray::Array2;

pub mod app; 
pub mod io;  
pub use app::TemplateApp;

#[derive(Debug)] 
pub struct EEGInfo {
    pub num_ch: i32,
    pub ch_namesx: Vec<String>,
    pub ch_names: Vec<String>,
    pub sfreq: i32,
    pub data_orientation: String,
    pub binary_format: String,
    pub sampling_interval_in: String,
    pub sampling_interval: i32,
}

#[derive(Debug)] 
pub struct EEGData {
    pub data: Array2<i16>,
}


use std::fs;
use clap::Parser;
use ndarray::prelude::*;
//use plotly::{Plot, Scatter};
use eframe::NativeOptions;


// My stuff
mod io;
mod gui;
mod app;

use reegui::EEGInfo;
use reegui::EEGData;

//use std::any::type_name;
//fn type_of<T>(_: T) -> &'static str {
  //  type_name::<T>()
//}

// CLI code
// underscores will be converted to "-" when clap parses the arguments
#[derive(Parser)]
#[command(name = "reeg")]
#[command(version = "0.1.0")]
#[command(about = "Does awesome EEG things", long_about = None)]
pub struct Cli {
    
    /// File path of the .vhdr if BV (str)
    #[arg(long, required_if_eq("format", "brainvision"))]
    hfpath: Option<String>,

    /// File path of the .eeg if BV or .edf if EDF (str)
    #[arg(long)]
    dfpath: String,

    /// Read and display the data as a table
    #[arg(short, long)]
    read_data: bool,

    /// Select data format (Brainvision or EDF)
    #[arg(short, long)]
    format: String,

    /// View data in reader (bool)
    #[arg(short, long)]
    view: bool,
}

 

fn check(data: &Array2<f32>, eeg_info: &EEGInfo) {
    let view = data.view();
    println!("VIEW {:?}", view);
    println!("DATA {:?}", data.dim());
    println!("ROW 1 {:?}", data.row(1).shape());
    for c in data.outer_iter() {
        println!("C {:?} {:?}", c.first(), c.last())
    }
}
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cli = Cli::parse();

    match cli.read_data {
        true => {
            println!("Reading from fpath {:?}", cli.hfpath);
            let header = io::get_header(&cli.hfpath)?;
            //println!("Header: {:?}", header);
            let eeg_info = io::parse_header(&header)?;
            println!("Reading from fpath {:?}", cli.dfpath);
            let samples = io::parse_bytes(&cli.dfpath, &eeg_info)?;
            let times = io::convert_to_seconds(samples, &eeg_info)?;
            println!("TIMES: {:?}", times.len());
            let channels = io::demultiplex(times, &eeg_info);
            println!("DATA READ");
            //println!("CHANNELS {:?}", &channels.unwrap().len());
            let data = io::vec_to_ndarray(channels.unwrap());
            println!("SHAPE OF DATA {:?}", data.shape());
            println!("Row {:?}", &data.row(0).len());
            println!("Column {:?}", &data.column(0).len());

        }

        _ => {}
    };

   let _ = match cli.view {
        true => {
            
            match cli.format.as_str() {
            
            "brainvision" => {
                    
                println!("Reading from fpath {:?}", cli.hfpath);
                let header = io::get_header(&cli.hfpath)?;
                //println!("Header: {:?}", header);
                let eeg_info = io::parse_header(&header)?;
                println!("Reading from fpath {:?}", cli.dfpath);
                let samples = io::parse_bytes(&cli.dfpath, &eeg_info)?;
    
                let metadata = fs::metadata(&cli.dfpath)?;
                let file_size_bytes = metadata.len();
                let expected_size_from_samples = samples.len() * 2; // 2 bytes per i16 sample
                
                println!("[Verification] EEG file size on disk: {} bytes", file_size_bytes);
                println!("[Verification] Size calculated from parsed samples: {} bytes", expected_size_from_samples);
                if file_size_bytes == expected_size_from_samples as u64 {
                    println!("Total sample count matches file size.");
                } else {
                    println!("ERROR: Mismatch between file size and parsed samples!");
                }
                let times = io::convert_to_seconds(samples, &eeg_info)?;
                println!("TIMES: {:?} seconds", times.len());
                let channels = io::demultiplex(times, &eeg_info);
                println!("DATA READ");
                //println!("CHANNELS {:?}", &channels.unwrap().len());
                let data = io::vec_to_ndarray(channels.unwrap());
                println!("SHAPE OF DATA {:?}", data.shape());
                let eeg_data = EEGData { data };
    
                let native_options = eframe::NativeOptions {
                    viewport: egui::ViewportBuilder::default()
                        .with_inner_size([400.0, 300.0])
                        .with_min_inner_size([300.0, 220.0])
                        .with_icon(
                            // NOTE: Adding an icon is optional
                            eframe::icon_data::from_png_bytes(&include_bytes!("../assets/icon-256.png")[..])
                                .expect("Failed to load icon"),
                        ),
                    ..Default::default()
                };
    
                eframe::run_native(
                    "reegui",
                    native_options,
                    Box::new(|cc| Ok(Box::new(reegui::TemplateApp::new(cc, eeg_info, eeg_data)))),
                )
                    
                }
                
            "edf" => {
                    
                println!("Reading from fpath {:?}", cli.dfpath);
                let edf = io::parse_edf(&cli.dfpath.as_str())?;
                //println!("Header: {:?}", header);
                /*
                let eeg_info = io::parse_header(&header)?;
                println!("Reading from fpath {:?}", cli.dfpath);
                let samples = io::parse_bytes(&cli.dfpath, &eeg_info)?;
    
                let metadata = fs::metadata(&cli.dfpath)?;
                let file_size_bytes = metadata.len();
                let expected_size_from_samples = samples.len() * 2; // 2 bytes per i16 sample
    
                println!("[Verification] EEG file size on disk: {} bytes", file_size_bytes);
                println!("[Verification] Size calculated from parsed samples: {} bytes", expected_size_from_samples);
    
                if file_size_bytes == expected_size_from_samples as u64 {
                    println!("Total sample count matches file size.");
                } else {
                    println!("ERROR: Mismatch between file size and parsed samples!");
                }
                let times = io::convert_to_seconds(samples, &eeg_info)?;
                println!("TIMES: {:?} seconds", times.len());
                let channels = io::demultiplex(times, &eeg_info);
                println!("DATA READ");
                //println!("CHANNELS {:?}", &channels.unwrap().len());
                let data = io::vec_to_ndarray(channels.unwrap());
                println!("SHAPE OF DATA {:?}", data.shape());
                let eeg_data = EEGData { data };
    
                let native_options = eframe::NativeOptions {
                    viewport: egui::ViewportBuilder::default()
                        .with_inner_size([400.0, 300.0])
                        .with_min_inner_size([300.0, 220.0])
                        .with_icon(
                            // NOTE: Adding an icon is optional
                            eframe::icon_data::from_png_bytes(&include_bytes!("../assets/icon-256.png")[..])
                                .expect("Failed to load icon"),
                        ),
                    ..Default::default()
                };
    
                eframe::run_native(
                    "reegui",
                    native_options,
                    Box::new(|cc| Ok(Box::new(reegui::TemplateApp::new(cc, eeg_info, eeg_data)))),
                )
                */
                Ok({})
                    
                }
            _ => {
                    println!("Error: Unknown format specified: {}", cli.format);
                    Ok(())
                }
             }

        }
        _ => Ok({})

    };

    Ok(())
}

